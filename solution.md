##### Задание 1

with count_diff as(
	select u.id, 
	to_char(u.date_joined, 'YYYY-MM') as dt_reg, --Преобразование даты регистрации, помесячно
	(date(u2.entry_at) - date(u.date_joined))::numeric as diff	--Количество дней между регистрацией и первым входом diff 
	from users u
	join userentry u2 
	on u.id = u2.user_id),
--Рассчёт помесячно по дате регистрации сколько пользователей проявили активность после регистрации  
--в интервале 0,1,3,7,14,30,60 и 90 дней  
count_user as (select 
	dt_reg, 
	count(distinct case when diff >= 0 then id else null end) as days_0,
	count(distinct case when diff >= 1 then id else null end) as days_1,
	count(distinct case when diff >= 3 then id else null end) as days_3,
	count(distinct case when diff >= 7 then id else null end) as days_7,
	count(distinct case when diff >= 14 then id else null end) as days_14,
	count(distinct case when diff >= 30 then id else null end) as days_30,
	count(distinct case when diff >= 60 then id else null end) as days_60,
	count(distinct case when diff >= 90 then id else null end) as days_90
	from count_diff
	group by dt_reg
	order by dt_reg)
--Расчет результата в процентах, с точностью до 2-х знаков
--Общее число зарегистрировавшихся это  days_0
select dt_reg,
	round(days_0::numeric/days_0 * 100, 2) as days_0,
	round(days_1::numeric/days_0 * 100, 2) as days_1,
	round(days_3::numeric/days_0 * 100, 2) as days_3,
	round(days_7::numeric/days_0 * 100, 2) as days_7,
	round(days_14::numeric/days_0 * 100, 2) as days_14,
	round(days_30::numeric/days_0 * 100, 2) as days_30,
	round(days_60::numeric/days_0 * 100, 2) as days_60,
	round(days_90::numeric/days_0 * 100, 2) as days_90
from count_user

Выводы:
Анализ данных показал следующие тенденции:
1. Активность  на 0-й день близок к 100%. В первый день пользователи регистрируются и знакомятся с курсом.
2. К 7-му дню наблюдается значительное падение активности. Студенты приступают к изучению теоретической части программы курса.  
3. К 30-му дню активность стабилизируется, что говорит о том, что студенты для закрепления полученных знаний перешли к решению практических задач.
4. После 60-90 дней активность значительно снижается. Большинство студентов решили задачи практического курса. Остались лояльные пользователи решающие бонусные задачи.
Оптимальный срок тарифа: 
Наибольшая активность наблюдается в первые 30 дней. После этого периода активность резко падает,  Что делает месячный тариф оптимальным.
•	Короткий срок (1 месяц) соответствует пику активности.
•	Длинные тарифы (60-90 дней) менее выгодны из-за низкой активности.
 

 
#### Задание 2

with count_deb_accr as(
	select 
	sum(case when t.type_id in(1,23,24,25,26,27,28,30) then value else 0 end) as debiting, --Расчёт списаний
	sum(case when t.type_id  not in(1,23,24,25,26,27,28,30) then value else 0 end) as accruals --Расчёт начислений
	from transaction t
	group by user_id)
select	
	round(avg(accruals), 0) as avg_accruals, --среднее начисление
	round(avg(debiting), 0) as avg_debiting, --среднее списание
	round(avg(accruals - debiting), 0) as avg_balance, --средний баланс
	percentile_cont(0.5) within group(order by(accruals - debiting)) as median_balance --медианный баланс
from count_deb_accr

--Среднее начисление 307
--Среднее списание 31 
--Средний баланс 275
--Медианный баланс 62

Анализ метрик баланса пользователей
1.	Среднее начисление: 307 коинов
	Это значение показывает, сколько в среднем коинов получает один пользователь. Оно значительно превышает средний расход, что  указывает на общий рост балансов пользователей.
2.	Среднее списание: 31 коин
	Средний расход коинов существенно ниже среднего начисления. Это  означает, что пользователи либо не активно тратят коины, либо имеют ограниченные возможности для их использования.
3.	Средний баланс: 275 коинов
	В среднем у пользователей достаточно высокий баланс, что подтверждает  накопление коинов из-за низких расходов.
4.	Медианный баланс: 62 коина
	Значение медианного баланса значительно ниже среднего. Это говорит о сильной асимметрии в распределении балансов — у небольшой части пользователей накоплены большие суммы, тогда как у большинства баланс ниже среднего.
Выводы:
	Начисления коинов значительно превышает их расход.
	Низкий медианный баланс по сравнению со средним указывает на неравномерность распределения коинов: большинство пользователей имеют относительно небольшие суммы, а крупные балансы сосредоточены у меньшинства.
	Для стимулирования активного использования коинов, стоит стимулировать траты.
Как повысить активность расходования коинов пользователями
1. Создание новых стимулов для расходов
-	доступ к дополнительным материалам.
-	Ограниченные предложения – временные акции, скидки и спецпредложения.
2. Ограничение накопления коинов
-	Срок годности коинов – введение механики сгорания коинов через определенный срок, если они не используются.
-	Ограничение максимального баланса – пользователи не могут накапливать больше определенного количества коинов, что стимулирует их тратить.
3. Стимулирование расходов
-	Эксклюзивные преимущества – доступ к премиум-контенту, ранний доступ к новым возможностям или персонализированные предложения за оплату.
-	Бонус за траты – кэшбэк.
Вывод:
Для повышения активности расходования коинов необходимо ограничение накопления, увеличение ценности расходов. Ограничение накопления и временные акции помогут поддерживать баланс между начислением и расходом.


#### Задание 3

WITH solved_tasks AS (
    SELECT user_id, COUNT(DISTINCT problem_id) AS task_count  --Расчёт сколько решает задач пользователь
    FROM codesubmit
    WHERE is_false = 0
    GROUP BY user_id
),
started_tests AS (
    SELECT user_id, COUNT(DISTINCT test_id) AS test_count --Расчёт сколько тестов проходит пользователь 
    FROM teststart
    GROUP BY user_id
),
attempts_per_task AS (
    SELECT user_id, problem_id, COUNT(*) AS attempts --Расчёт сколько попыток делает пользователь для решения 1 задачи
    FROM codesubmit
    GROUP BY user_id, problem_id
),
attempts_per_test AS (
    SELECT user_id, test_id, COUNT(*) AS attempts --Расчёт сколько попыток делает пользователь для прохождения 1 теста
    FROM teststart
    GROUP BY user_id, test_id
),
active_users AS (
    SELECT user_id FROM coderun
    UNION
    SELECT user_id FROM codesubmit
    UNION
    SELECT user_id FROM teststart
),
all_users AS (
    SELECT COUNT(id) AS total_users FROM users u  -- все зарегистрированные пользователи
)
SELECT    
    avg((SELECT ROUND(AVG(task_count), 2) FROM solved_tasks))AS avg_tasks_per_user, --Расчёт сколько в среднем пользователь решает задач
    avg((SELECT ROUND(AVG(test_count), 2) FROM started_tests)) AS avg_tests_per_user, --Расчёт сколько в среднем пользователь проходит тестов
    avg((SELECT ROUND(AVG(attempts), 2) FROM attempts_per_task)) AS avg_attempts_per_task, --Расчёт сколько в среднем пользователь делает попыток для решения 1 задачи
    avg((SELECT ROUND(AVG(attempts), 2) FROM attempts_per_test)) AS avg_attempts_per_test, --Расчёт сколько в среднем пользователь делает попыток для прохождения 1 теста
    ROUND(
        (SELECT COUNT(DISTINCT user_id) FROM active_users)::numeric / 
        (SELECT total_users FROM all_users)::numeric,
    4
)*100 AS active_users_ratio_percent --Расчёт доли от общего числа пользователей решала хотя бы одну задачу или начинала проходить хотя бы один тест в %
from active_users

Выводы:
1.	Среднее количество решенных задач пользователем  11 (10,53).
Количество попыток на решение 1 задачи 3 (2,9)
Это говорит о высокой вовлеченности пользователей. Задачи достаточно интересны. Разнообразны: от простых к сложным. Имеются рекомендации, подсказки и примеры решения. После решения задачи пользователю предоставляется доступ к разбору варианта решения задачи. Для продвинутых пользователей есть дополнительно выбор сложных задач.
2.	Среднее количество пройденных тестов 2 (1,68)
Количество попыток на прохождения 1 теста 1,26
Тесты проходят 1-2 попыток. Это означает что, теоретический материал достаточно хорошо изложен преподавателем, и студент достаточно легко закрепляет полученные знания при прохождении теста.
3.	63,48% от общего числа пользователей решала хотя бы одну задачу или начинала проходить хотя бы один тест.

#### Дополнительное задание.
    
--1. Доля задач, решенных с первой попытки
--Описание: Процент задач, которые пользователи решили правильно без ошибок с первого раза.
--Полезность: Показывает соответствие сложности задач уровню подготовки пользователей
    
WITH first_attempt AS (
    SELECT 
        user_id,
        problem_id,
        MIN(created_at) AS first_submit_time,
        MAX(CASE WHEN is_false = 0 THEN 1 ELSE 0 END) AS is_solved_on_first_try --количество задач решенных с 1 попытки
    FROM codesubmit
    GROUP BY user_id, problem_id
)
SELECT 
    ROUND(
        SUM(is_solved_on_first_try)::numeric / COUNT(*)::numeric * 100, 
        2
    ) AS first_try_success_rate --доля задач решенных с 1 попытки
FROM first_attempt

Вывод: 
Доля задач решенных с первой попытки составляет 91,75%. Высокая доля успеха говорит о том, что большая часть пользователей уже включена в процесс.
Стоит изучить, какие типы задач решаются легче, а какие вызывают затруднения, для выявления наиболее сложных тем.
Что можно включить в платную подписку:
1. Эксклюзивные обучающие материалы
2. Более сложные задачи с подробным разбором решения задач
3. Различные варианты решения задач
	   


--2. Доля пользователей с прогрессом в задачах
--Описание: Процент пользователей, решивших хотя бы одну задачу правильно после неудачных попыток.
--Полезность: Показывает, насколько пользователи готовы повторять попытки и улучшать результаты.

WITH user_progress AS (
    SELECT 
        user_id,
        problem_id,
        MAX(CASE WHEN is_false = 0 THEN 1 ELSE 0 END) AS eventually_solved
    FROM codesubmit
    GROUP BY user_id, problem_id
)
SELECT   
        round(COUNT(DISTINCT user_id) FILTER (WHERE eventually_solved = 1)::numeric/ 
        COUNT(DISTINCT user_id)::numeric * 100, 2) as progress_rate_percent
FROM user_progress

Выводы:
Доля пользователей с прогрессом в задачах состаляет 82,93%, говорит о высокой устойчивости пользователей к обучению. 
Большинство после неудачных попыток не сдаются и продолжают искать правильное решение.
Что значит:
- у пользователей высокий интерес к практическим задачам
- высокая эффективность системы подсказок. Подсказки мпомогают найти правильное решение
- после нескольких попыток пользователи лучше понимают материал
Как улучшить показатель:
- Добавить детальное обЪяснение после неправильного ответа
-  Предложить альтернативные методы решения задач
- Выявить какие типы задач вызывают больше всего проблем
- Бонусы за решение задачи с 1 раза
- Внедрение интерактивных подсказок, дающих направление, объяснение ошибки или дополнительные примеры.
Функции для платной подписки:
1. Видеоразбор сложных задач
2. Уникальные задачи, связанные с реальными кейсами
3. Симуляция реальных рабочих ситуаций



--3. Соотношение потраченных и заработанных кодкоинов
--Описание: Среднее отношение суммы потраченных кодкоинов к заработанным для каждого пользователя.
--Полезность: Помогает оценить баланс между мотивацией (награды) и вовлечением (траты).

WITH earnings AS (
    SELECT 
        user_id,
        SUM(value) AS total_earned
    FROM transaction
    WHERE type_id IN (2, 3, 6, 7, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21) -- типы начислений
    GROUP BY user_id
),
spendings AS (
    SELECT 
        user_id,
        SUM(value) AS total_spent
    FROM transaction
    WHERE type_id IN (5, 8, 9, 10, 11, 23, 24, 25, 26, 27, 28) -- типы списаний
    GROUP BY user_id
)
SELECT 
    ROUND(
        AVG(CASE WHEN total_earned = 0 then 0 ELSE COALESCE(total_spent, 0) / total_earned END)::numeric, 2
    ) AS earning_spending_ratio
FROM earnings
LEFT JOIN spendings USING (user_id)

 Выводы:
 Средний коэффициент 0,46 означает , что пользователи тратят меньше кодкоинов, чем зарабатывают.
 Пользователи не тратят все заработанные кодкоины, делают накопления для предстоящих более трудных задач.
 Как стимулировать траты:
 1. Добавить эксклюзивные бонусы (доступ к премиальному контенту или скидки на подписку) 
 2. Сделать кодкоины ключевой валютой для образовательных привилегий
 3. Ограниченные по времени предложения: кодкоины можно потратить на уникальные материалы, но только в определенные сроки
 4. Включить систему инвестирования, где пользователи могут использовать кодкоины для получения полезных инструментов, улучшенных задач, или персональных рекомендаций
 5. Ввести челленджи, где кодкоины необходимы для участия 
 
 
#### Итоговые выводы по смене модели монетизации

На основе анализа активности пользователей определены оптимальные сроки тарифов:
- Краткосрочный – 7 дней
- Базовый – 30 дней
- Долгосрочный – 90 дней

Исходя из средних показателей баланса пользователей, оптимальная стоимость подписки:
- Краткосрочный тариф – 50 кодкоинов
- Базовый тариф – 150 кодкоинов (при продлении подписки на следующий месяц предоставляется скидка 30%)
- Долгосрочный тариф – 300 кодкоинов

В состав платной подписки, учитывая активность пользователей по покупкам, включить:
- Доступ к дополнительным задачам и тестам
- Безлимитное количество посказок (в бесплатной версии ограничить количество посказок)
- Готовые решения и варианты решений с поэтапными подробными объяснениями (В бесплатной версии оставить только пример решения)
- Примеры реальных бизнес-кейсов с решениями и комментариями
 
 
#### Дополнительное задание 2

--Анализ активности пользователей на платформе по дням недели и времени суток

--SQL запрос--
WITH all_activities AS (
    SELECT 
        user_id,
        created_at,
        'coderun' AS activity_type
    FROM coderun
    UNION ALL
    SELECT 
        user_id,
        created_at,
        'codesubmit' AS activity_type
    FROM codesubmit
    UNION ALL
    SELECT 
        user_id,
        created_at,
        'teststart' AS activity_type
    FROM teststart
)
SELECT 
    -- Час активности
    EXTRACT(HOUR FROM created_at) AS hour_of_day,
    COUNT(*) AS total_activities
FROM all_activities
GROUP BY hour_of_day
ORDER BY hour_of_day

--Анализ активности по дням и времени суток
WITH all_activities AS (
    SELECT created_at FROM coderun
    UNION ALL
    SELECT created_at FROM codesubmit
    UNION ALL
    SELECT created_at FROM teststart
)
SELECT 
    -- День недели (с названием)
    CASE 
        WHEN EXTRACT(DOW FROM created_at) = 0 THEN 'Sunday'
        WHEN EXTRACT(DOW FROM created_at) = 1 THEN 'Monday'
        WHEN EXTRACT(DOW FROM created_at) = 2 THEN 'Tuesday'
        WHEN EXTRACT(DOW FROM created_at) = 3 THEN 'Wednesday'
        WHEN EXTRACT(DOW FROM created_at) = 4 THEN 'Thursday'
        WHEN EXTRACT(DOW FROM created_at) = 5 THEN 'Friday'
        WHEN EXTRACT(DOW FROM created_at) = 6 THEN 'Saturday'
    END AS day_of_week,   
    EXTRACT(HOUR FROM created_at) AS hour_of_day, -- Час активности    
    COUNT(*) AS total_actions,  -- Общее количество активностей   
    ROUND(
        COUNT(*) * 100.0 / SUM(COUNT(*)) OVER (), 
        2
    ) AS percent_of_total     -- Доля от общего числа (для нормировки)
FROM all_activities
GROUP BY day_of_week, hour_of_day
ORDER BY 
    EXTRACT(DOW FROM MIN(created_at)), -- Сортировка по порядку дней недели
    hour_of_day

--Построение графика 

--Python код--

# импорт библиотек
import pandas as pd
import matplotlib.pyplot as plt
# загружаем таблицу активности пользователей на платформе
df = pd.read_csv("D:/SF EDUCATION/Кейс по курсу бизнес анализ/Дипломный проект по бизнес аналитике Щетко О.Н/Tables/Активность по дням недели и времени суток.csv", sep=',')
# проверяем загруженную таблицу
df.head()
# убираем кавычки из названий столбцов
df.columns = ['day_of_week', 'hour_of_day', 'total_actions']
df
# преобразуем столбец 'hour_of_day' в целочисленный тип
df['hour_of_day'] = df['hour_of_day'].astype(int)
# проверяем результат преобразования
print(df.dtypes)
print(df.info())
print(df.head())
# устанавливаем порядок дней недели с понедельника
weekday_order = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
# преобразуем столбец day_of_week в категорию с указанным порядком
df['day_of_week'] = pd.Categorical(df['day_of_week'], categories=weekday_order, ordered=True)
# преобразуем данные: группируем по дням недели и часам, суммируя действия
df_grouped = df.groupby(['day_of_week', 'hour_of_day'])['total_actions'].sum().reset_index()
# проверяем результат группировки
print(df_grouped.head())
# строим тепловой график активности пользователей на платформе по дням недели и времени суток
plt.figure(figsize=(12, 6))
sns.heatmap(
    df_grouped.pivot(index='day_of_week', columns='hour_of_day', values='total_actions'),
    cmap='coolwarm',
    annot=False,
    cbar_kws={'label': 'Total Actions'}
)
plt.title('График распределения посещений по дням недели и времени суток')
plt.xlabel('Час дня')
plt.ylabel('День недели')
plt.show()

На основе анализа активности пользователей по дням недели и времени суток можно определить оптимальные интервалы для релизов нового функционала:
Анализ активности:
•	Пиковые часы:
 -	Вторник, среда, четверг 12:00-21:00 — высокая активность, особенно 
 -	Пятница 10:00-20:00 — стабильная активность с увеличением к вечеру.
 -	Суббота 10:00-21:00 — высокий уровень активности, особенно с 12:00 до 19:00.
 -	Воскресенье 10:00-21:00 — активность держится стабильно весь день.
 -	Минимальная активность наблюдается ночью (0:00-6:00) и ранним утром (до 9:00).
Оптимальное время для релизов:
1.	Ночь (02:00–06:00)
 	Минимальное количество пользователей активно на платформе, что снижает вероятность массовых технических сбоев.
 	Можно проводить запланированные обновления без существенного влияния на пользователей.
2.	Утро (06:00–09:00)
 	Достаточно низкий трафик, но более высокий, чем ночью.
 	Хороший вариант для небольших релизов и исправлений.
3.	Альтернативный вариант — поздний вечер (22:00–01:00)
 	Активность пользователей снижается, но платформа ещё используется.
 	Подходит для обновлений, которые не требуют немедленного вмешательства пользователей.
Рекомендации:
✔ Релизы крупных обновлений лучше проводить с 02:00 до 06:00, когда минимальная нагрузка. 
✔ Минорные исправления можно выкатывать ранним утром (06:00–09:00). 
✔ Тестирование перед массовым релизом можно делать поздним вечером (22:00–01:00). 
✔ Пиковые периоды активности лучше использовать для мониторинга стабильности и получения обратной связи.

Оптимальные дни для релизов
Понедельник, Вторник, Среда
 	Эти дни имеют высокую активность днём и вечером, но утром наблюдается спад, что делает их удобными для релизов.
 	Рекомендуемое время: 02:00–09:00.
Четверг и Пятница
  	Активность возрастает к концу недели, но ночью и ранним утром остаётся низкой.
 	Рекомендуемое время: 02:00–07:00.
Суббота и Воскресенье
  	Высокая активность пользователей в течение дня.
  	Лучше избегать масштабных релизов, но минорные можно делать до 06:00.
Вывод
 Оптимальное время для крупных обновлений: 02:00–06:00 в понедельник, вторник или четверг.
 Минорные исправления: 06:00–09:00 в понедельник-пятницу. 
Тестирование на активной аудитории: 22:00–01:00 в будние дни.
